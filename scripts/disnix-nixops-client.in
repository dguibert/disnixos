#!/bin/bash -e
# DisnixOS - Infrastructure deployment extension for Disnix
# Copyright (C) 2008-2015  Sander van der Burg
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

showUsage()
{
    echo "Usage:"
    echo "$0 --target hostname {operation}"
    echo
    echo "Operations:"
    echo "  --import [--localfile|--remotefile] derivations"
    echo "  --export [--localfile|--remotefile] derivations"
    echo "  --print-invalid derivations"
    echo "  {-r|--realise} derivations"
    echo "  --set [{-p|--profile} name] derivation"
    echo "  {-q|--query-installed} [{-p|--profile} name]"
    echo "  --query-requisites derivations"
    echo "  --collect-garbage [{-d|--delete-old}]\n"
    echo "  --activate --type type --arguments arguments derivation"
    echo "  --deactivate --type type --arguments arguments derivation"
    echo "  --lock [{-p|--profile} profile]"
    echo "  --unlock [{-p|--profile} profile]"
    echo "  --snapshot --type type --arguments arguments derivation"
    echo "  --restore --type type --arguments arguments derivation"
    echo "  --delete-state --type type --arguments arguments derivation"
    echo "  --query-all-snapshots --container container --component component"
    echo "  --query-latest-snapshot --container container --component component"
    echo "  --print-missing-snapshots snapshots"
    echo "  --import-snapshots paths"
    echo "  --export-snapshots paths"
    echo "  --resolve-snapshots snapshots"
    echo "  --clean-snapshots"
    echo "  {-h | --help}"
}

# Autoconf settings
export prefix=@prefix@

# Import Disnix checks
source @DISNIX_PREFIX@/share/disnix/checks

# Parse valid argument options

PARAMS=`@getopt@ -n $0 -o rqp:d -l import,export,print-invalid,realise,set,query-installed,query-requisites,collect-garbage,activate,deactivate,lock,unlock,snapshot,restore,delete-state,query-all-snapshots,query-latest-snapshot,print-missing-snapshots,import-snapshots,export-snapshots,resolve-snapshots,clean-snapshots,target:,localfile,remotefile,profile:,delete-old,type:,arguments:,container:,component:,help -- "$@"`

if [ $? != 0 ]
then
    showUsage
    exit 1
fi

eval set -- "$PARAMS"

# Evaluate valid options

while [ "$1" != "--" ]
do
    case "$1" in
        --import)
            operation="import"
            ;;
        --export)
            operation="export"
            ;;
        --print-invalid)
            operation="print-invalid"
            ;;
        -r|--realise)
            operation="realise"
            ;;
        --set)
            operation="set"
            ;;
        -q|--query-installed)
            operation="query-installed"
            ;;
        --query-requisites)
            operation="query-requisites"
            ;;
        --collect-garbage)
            operation="collect-garbage"
            ;;
        --activate)
            operation="activate"
            path=$2
            ;;
        --deactivate)
            operation="deactivate"
            path=$2
            ;;
        --lock)
            operation="lock"
            path=$2
            ;;
        --unlock)
            operation="unlock"
            path=$2
            ;;
        --snapshot)
            operation="snapshot"
            path=$2
            ;;
        --restore)
            operation="restore"
            path=$2
            ;;
        --delete-state)
            operation="delete-state"
            ;;
        --query-all-snapshots)
            operation="query-all-snapshots"
            ;;
        --query-latest-snapshot)
            operation="query-latest-snapshot"
            ;;
        --print-missing-snapshots)
            operation="print-missing-snapshots"
            ;;
        --import-snapshots)
            operation="import-snapshots"
            ;;
        --export-snapshots)
            operation="export-snapshots"
            ;;
        --resolve-snapshots)
            operation="resolve-snapshots"
            ;;
        --target)
            target=$2
            ;;
        --localfile)
            localfile=1
            ;;
        --remotefile)
            remotefile=1
            ;;
        -p|--profile)
            profileArg="--profile $2"
            ;;
        -d|--delete-old)
            deleteOldArg="-d"
            ;;
        --type)
            type=$2
            ;;
        --arguments)
            argsArg="$argsArg --arguments \"$2\""
            ;;
        -C|--container)
            container=$2
            ;;
        -c|--component)
            component=$2
            ;;
        -h|--help)
            showUsage
            exit 0
            ;;
    esac
    
    shift
done

shift

# Validate the given options

checkTarget
checkTmpDir

# Execute selected operation

case "$operation" in
    import)
        if [ "$localfile" != "1" ] && [ "$remotefile" != "1" ]
        then
            echo "ERROR: Either a remote or a localfile must be specified!" >&2
            exit 1
        fi
        
        # A localfile must first be transferred
        if [ "$localfile" != "" ]
        then
            remotefile=`nixops ssh $target "mktemp -p $TMPDIR"`
            nixops scp $NIXOPS_OPTS --to $target "$@" $remotefile
        fi
        
        # Import the closure into the Nix store
        nixops ssh $NIXOPS_OPTS $target "disnix-client --import $remotefile"
        ;;
    export)
        if [ "$localfile" != "1" ] && [ "$remotefile" != "1" ]
        then
            echo "ERROR: Either a remote or a localfile must be specified!" >&2
            exit 1
        fi

        closure=`nixops ssh $NIXOPS_OPTS $target "disnix-client --export $@"`
        
        # A remote file must be downloaded afterwards
        if [ "$remotefile" = "1" ]
        then
            localClosure=`mktemp -p $TMPDIR`
            nixops scp --from $NIXOPS_OPTS $target $closure $localClosure > /dev/null
            echo $localClosure
        fi
        ;;
    print-invalid)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --print-invalid $@"
        ;;
    realise)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --realise $@"
        ;;
    set)
        nixops ssh $NIXOPS_OPTS $target "disnix-client $profileArg --set $@"
        ;;
    query-installed)
        nixops ssh $NIXOPS_OPTS $target "disnix-client $profileArg --query-installed $@"
        ;;
    query-requisites)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --query-requisites $@"
        ;;
    collect-garbage)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --collect-garbage $deleteOldArg $@"
        ;;
    activate)
        if [ "$type" = "" ]
        then
            echo "ERROR: A type must be specified!" >&2
            exit 1
        fi
        
        nixops ssh $NIXOPS_OPTS $target "disnix-client --type $type $argsArg --activate $@"
        ;;
    deactivate)
        if [ "$type" = "" ]
        then
            echo "ERROR: A type must be specified!" >&2
            exit 1
        fi
        
        nixops ssh $NIXOPS_OPTS $target "disnix-client --type $type $argsArg --deactivate $@"
        ;;
    lock)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --lock $profileArg"
        ;;
    unlock)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --unlock $profileArg"
        ;;
    snapshot)
        if [ "$type" = "" ]
        then
            echo "ERROR: A type must be specified!" >&2
            exit 1
        fi
        
        nixops ssh $NIXOPS_OPTS $target "disnix-client --type $type $argsArg --snapshot $@"
        ;;
    restore)
        if [ "$type" = "" ]
        then
            echo "ERROR: A type must be specified!" >&2
            exit 1
        fi
        
        nixops ssh $NIXOPS_OPTS $target "disnix-client --type $type $argsArg --restore $@"
        ;;
    delete-state)
        if [ "$type" = "" ]
        then
            echo "ERROR: A type must be specified!" >&2
            exit 1
        fi
        
        nixops ssh $NIXOPS_OPTS $target "disnix-client --type $type $argsArg --delete-state $@"
        ;;
    query-all-snapshots)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --query-all-snapshots --container $container --component $component"
        ;;
    query-latest-snapshot)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --query-latest-snapshot --container $container --component $component"
        ;;
    print-missing-snapshots)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --print-missing-snapshots $@"
        ;;
    import-snapshots)
        if [ "$localfile" != "1" ] && [ "$remotefile" != "1" ]
        then
            echo "ERROR: Either a remote or a localfile must be specified!" >&2
            exit 1
        fi
        
        # A localfile must first be transferred
        if [ "$localfile" = "1" ]
        then
            remotefile=`nixops ssh $NIXOPS_OPTS $target "mktemp -d -p $TMPDIR"`
            nixops scp $NIXOPS_OPTS --to $target $@ $remotefile
        fi
        
        nixops ssh $NIXOPS_OPTS $target "disnix-client --container $container --component $component --import-snapshots "$remotefile/*
        ;;
    export-snapshots)
        tmpdir=`mktemp -d -p $TMPDIR`
        for i in $@
        do
            nixops scp $NIXOPS_OPTS --from $target $i $tmpdir
        done
        
        echo $tmpdir
        ;;
    resolve-snapshots)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --resolve-snapshots $@"
        ;;
    clean-snapshots)
        nixops ssh $NIXOPS_OPTS $target "disnix-client --clean-snapshots $@"
        ;;
esac
