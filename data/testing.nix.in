{ nixpkgs ? <nixpkgs>
, system ? builtins.currentSystem
, disnix ? builtins.storePath @DISNIX_PREFIX@
, disnixos ? builtins.storePath @prefix@
}:

let
  pkgs = import nixpkgs {};
  
  generateManifestSrc =
    {name, tarball}:
    
    pkgs.stdenv.mkDerivation {
      name = "${name}-manifest-src";
      buildCommand =
        ''
          mkdir -p $out
          cd $out
          tar xfvj ${tarball}/tarballs/*.tar.bz2 --strip-components=1
        '';
    };
in
{
  sourceTarball =
    {name, version, src, officialRelease}:
    
    pkgs.releaseTools.sourceTarball {
      inherit name version src officialRelease;
      
      distPhase =
        ''
          mkdir ../$name
          rm -Rf `find . -name .svn`
          mv * ../$name
          cd ..
          mkdir -p $out/tarballs
          tar cfvj $out/tarballs/$name.tar.bz2 $name
        '';
    };

  buildManifest = 
    {name, version, tarball, servicesFile, networkFile, externalNetworkFile ? false, distributionFile, externalDistributionFile ? false}:
    
    pkgs.releaseTools.nixBuild rec {
      inherit name version;
      src = tarball;
      
      manifestSrc = generateManifestSrc {
        inherit name tarball;
      };
      
      infrastructure = import "${disnixos}/share/disnixos/generate-infrastructure.nix" {
        networkFiles = [ (if externalNetworkFile then networkFile else "${manifestSrc}/${networkFile}") ];
        useVMTesting = true;
        useBackdoor = true;
        inherit nixpkgs;
      };
      
      manifest = import "${disnix}/share/disnix/manifest.nix" {
        servicesFile = "${manifestSrc}/${servicesFile}";
        infrastructureFile = "${infrastructure}";
        distributionFile = if externalDistributionFile then distributionFile else "${manifestSrc}/${distributionFile}";
        targetProperty = "backdoor";
        clientInterface = "${disnixos}/bin/disnix-backdoor-client";
        inherit nixpkgs;
      };
      
      installPhase =
        ''
          mkdir -p $out
          ln -s $manifest $out/manifest.xml
        '';

      checkPhase = "echo hello";
    };

  disnixTest =
    {name, manifest, tarball, networkFile, externalNetworkFile ? false, testScript}:
    
    let
      manifestSrc = generateManifestSrc {
        inherit name tarball;
      };
      
      network = if externalNetworkFile then import networkFile else import "${manifestSrc}/${networkFile}";
    in
    with import "${nixpkgs}/nixos/lib/testing.nix" { inherit system; };
    
    simpleTest {
      nodes = network;
      
      testScript =
        ''
          startAll;

          ${pkgs.lib.concatMapStrings (targetName:
          ''
            ${"\$"}${targetName}->waitForJob("network.target");
            ${"\$"}${targetName}->waitForJob("disnix.service");
            ${"\$"}${targetName}->mustSucceed("iptables -I INPUT -p tcp --dport 512 -j ACCEPT || true");
            my $pid = ${"\$"}${targetName}->mustSucceed("${pkgs.socat}/bin/socat tcp-listen:512,fork exec:/bin/sh & echo -n \$!");
            ${"\$"}${targetName}->mustSucceed("while [ \"\$(ps -p $pid | grep socat)\" = \"\" ]; do sleep 0.5; done");
    
          '') (builtins.attrNames network)}
          
          ${"\$"}${builtins.head (builtins.attrNames network)}->mustSucceed("${disnix}/bin/disnix-activate --no-coordinator-profile --no-lock --no-upgrade ${manifest}/manifest.xml");
  
          ${testScript}
        '';
    };
}
